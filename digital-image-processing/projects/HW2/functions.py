import numpy as np, cv2, math
from typing import Tuple, Optional, Dict, List
import matplotlib.pyplot as plt
import cv2
def return_names_IDs():
    name1 = None  
    id1 = None    
    
    # If working in pairs, fill in your partner's details as well
    name2 = None  
    id2 = None   
    # Return a formatted string with both students' names and IDs
    # NOTE: This will be used for assignment identification and grading
    return name1, id1, name2, id2

def _rotate_and_translate(pts: np.ndarray, angle_deg: float, center: Tuple[int,int]) -> np.ndarray:
    M = cv2.getRotationMatrix2D((0, 0), angle_deg, 1.0)
    pts = np.asarray(pts, np.float32)
    pts_rot = cv2.transform(pts[None, ...], M)[0]
    pts_rot[:, 0] += center[0]
    pts_rot[:, 1] += center[1]
    return pts_rot.astype(np.int32)

def _iou(boxA, boxB) -> float:
    xA, yA = max(boxA[0], boxB[0]), max(boxA[1], boxB[1])
    xB, yB = min(boxA[2], boxB[2]), min(boxA[3], boxB[3])
    inter_w, inter_h = max(0, xB - xA), max(0, yB - yA)
    inter_area = inter_w * inter_h
    if inter_area == 0:
        return 0.0
    areaA = (boxA[2]-boxA[0]) * (boxA[3]-boxA[1])
    areaB = (boxB[2]-boxB[0]) * (boxB[3]-boxB[1])
    return inter_area / float(areaA + areaB - inter_area)

def _rotate_and_translate(points: np.ndarray, angle: float, center: Tuple[int, int]) -> np.ndarray:
    theta = np.radians(angle)
    rot = np.array([[np.cos(theta), -np.sin(theta)],
                    [np.sin(theta),  np.cos(theta)]], dtype=np.float32)
    return (points @ rot.T + np.array(center)).astype(np.int32)

def _rotate_and_translate(points: np.ndarray, angle: float, center: Tuple[int, int]) -> np.ndarray:
    theta = np.radians(angle)
    rot = np.array([[np.cos(theta), -np.sin(theta)],
                    [np.sin(theta),  np.cos(theta)]], dtype=np.float32)
    return (points @ rot.T + np.array(center)).astype(np.int32)

def generate_shape(
    shape: str = "circle",
    h: int = 256,
    w: int = 256,
    size: float = 50,
    angle: float = 0.0,
    bg: int = 0,
    color: int = 255,
    blur_sigma_range: Tuple[float, float] = (0.0, 2.5), 
    rng: Optional[np.random.Generator] = None
) -> np.ndarray:
    """
    Generate a clean image with a single shape: 'circle', 'rectangle', or 'triangle'.
    Ensures the shape fits entirely in the image, even after rotation.
    Applies random Gaussian blur with sigma in blur_sigma_range.
    """
    rng = rng or np.random.default_rng()
    img = np.full((h, w), bg, dtype=np.uint8)

    # --- Compute safe padding ---
    if shape == "circle":
        safe_pad = int(size) + 1
    elif shape == "rectangle":
        rect_w = size * 1.5
        rect_h = size
        safe_pad = int(np.sqrt(rect_w**2 + rect_h**2) / 2) + 1
    else:
        safe_pad = int(np.sqrt(2) * size) + 1

    cx = int(rng.integers(safe_pad, w - safe_pad))
    cy = int(rng.integers(safe_pad, h - safe_pad))

    if shape == "circle":
        r = int(size)
        cv2.circle(img, (cx, cy), r, color, -1)

    elif shape == "rectangle":
        rect_w = size * 1.5
        rect_h = size
        rect = np.array([
            [-rect_w / 2, -rect_h / 2],
            [ rect_w / 2, -rect_h / 2],
            [ rect_w / 2,  rect_h / 2],
            [-rect_w / 2,  rect_h / 2]
        ], dtype=np.float32)
        pts = _rotate_and_translate(rect, angle, (cx, cy))
        cv2.fillPoly(img, [pts], color)

    elif shape == "triangle":
        tri = np.array([
            [0, -1.15 * size],
            [ size, 0.65 * size],
            [-size, 0.65 * size]
        ], dtype=np.float32)
        pts = _rotate_and_translate(tri, angle, (cx, cy))
        cv2.fillPoly(img, [pts], color)

    else:
        raise ValueError(f"Unsupported shape: {shape}")

    # --- Apply random Gaussian blur ---
    sigma = float(rng.uniform(*blur_sigma_range))
    if sigma > 0:
        # kernel size: ensure it's odd and large enough for sigma
        ksize = int(6 * sigma + 1)
        if ksize % 2 == 0:
            ksize += 1
        img = cv2.GaussianBlur(img, (ksize, ksize), sigmaX=sigma, borderType=cv2.BORDER_REPLICATE)

    return img, shape





def shape_identifier(img):
    """
    Input : grayscale image generated by generate_shape
    Output: string "triangle", "rectangle", "circle"
    """
    edges_ref = cv2.Canny(img, 100, 200)
    plt.imshow(edges_ref, cmap='gray')
    plt.show()

    white_pixel_row_count=np.sum(edges_ref == 255, axis=1)
    white_pixel_column_count=np.sum(edges_ref == 255, axis=0)

    print(white_pixel_row_count)
    print(white_pixel_column_count)

    for i in range(len(white_pixel_row_count)):
        if white_pixel_row_count[i] != 0:
            row_start_index = i
            break
    for i in range(len(white_pixel_column_count)):
        if white_pixel_column_count[i] != 0:
            column_start_index = i
            break

    # ------------- Circle Detection -------------
    row_index = row_start_index
    column_index = column_start_index
    circle_flag = True
    while white_pixel_row_count[row_index] != 0:
        if white_pixel_column_count[column_index] != white_pixel_row_count[row_index]:
            circle_flag = False
            break
        row_index += 1
        column_index += 1


    # ------------- Rectangle Detection -------------
    row_index = row_start_index
    column_index = column_start_index
    rectangle_flag = True
    if white_pixel_row_count[row_index] != white_pixel_column_count[column_index]:
        rectangle_flag = False


    if circle_flag:
        shape = "circle"
    else:
        shape = "not a circle"
    
    return shape

# --- Generate the original shape ---
shapes = ["circle", "rectangle", "triangle"]
for shape in shapes:
    print(f"Testing {shape} shape")
    img, shape = generate_shape(shape=shape)
    student_shape = shape_identifier(img)
    print(f"Student's shape identification: {student_shape}, Real shape is: {shape}")